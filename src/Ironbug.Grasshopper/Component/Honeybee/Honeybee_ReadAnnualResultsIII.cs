using System;
using System.Collections.Generic;
using Grasshopper.Kernel;
using System.Linq;
using System.IO;

namespace Ironbug.Grasshopper.Component
{
    public class Honeybee_ReadAnnualResultsIII : GH_Component
    {
        static double Min = 300;
        static double Max = 0;
        static double OneHrPercent = 1 / 36.50;
        static List<int> Hours = new List<int>();

        /// <summary>
        /// Initializes a new instance of the Honeybee_ReadAnnualResultsIII class.
        /// </summary>
        public Honeybee_ReadAnnualResultsIII()
          : base("Honeybee_ReadAnnualResultsIII", "ReadAnnualResultsIII",
              "read the annual ill files very fast!!\n\nPlease find the source code from:\nhttps://github.com/MingboPeng/Ironbug",
              "Honeybee", "04 | Daylight | Daylight")
        {
        }
        public override GH_Exposure Exposure => GH_Exposure.secondary;

        /// <summary>
        /// Registers all the input parameters for this component.
        /// </summary>
        protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
        {
            pManager.AddTextParameter("_illFilesAddress", "_illFilesAddress", "A list of .ill files generated by Radiance", GH_ParamAccess.list);
            pManager.AddNumberParameter("_workingHours_", "_workingHours_", "a list of hours in 24H pormat, by default is from 8 - 18 (LEED v4)", GH_ParamAccess.list, new List<double>() { 8,9,10,11,12,13,14,15,16,17,18});
            pManager.AddNumberParameter("minThreshold", "minThreshold", "Default 300lux.", GH_ParamAccess.item, 300);
            pManager.AddNumberParameter("maxThreshold", "maxThreshold", "Default 0 (infinity).", GH_ParamAccess.item, 0);


        }
        /// <summary>
        /// Registers all the output parameters for this component.
        /// </summary>
        protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
        {
            pManager.AddNumberParameter("DA_lessThanRange", "lessThanRange", "% of total hours that is less than the minimum threshold", GH_ParamAccess.list);
            pManager.AddNumberParameter("DA_inTheRange", "inTheRange", "% of total hours that is between the minimum and maximum threshold", GH_ParamAccess.list);
            pManager.AddNumberParameter("DA_moreThanRange", "moreThanRange", "% of total hours that is larger than the maximum threshold", GH_ParamAccess.list);
            pManager.AddNumberParameter("CDA", "CDA", "% of total hours that is between the minimum and maximum threshold, with partial credits", GH_ParamAccess.list);
            //pManager.AddNumberParameter("sDA", "sDA", "% of area meets 50% of DA_inTheRange", GH_ParamAccess.item);
        }

        /// <summary>
        /// This is the method that actually does the work.
        /// </summary>
        /// <param name="DA">The DA object is used to retrieve from inputs and store in outputs.</param>
        protected override void SolveInstance(IGH_DataAccess DA)
        {
            List<string> lines = new List<string>();
            List<string> illFiles = new List<string>();
            List<double> hours = new List<double>();

            if (!DA.GetDataList(0, illFiles)) return;
            DA.GetDataList(1, hours);
            DA.GetData(2,ref Min);
            DA.GetData(3, ref Max);

            Hours = hours.Select(_ => (int)_).ToList();
            OneHrPercent = 1 / (3.65 * hours.Count);

            var AllProcessedData = new List<List<List<double>>>();

            var underTPercent = new List<double>();
            var withinTPercent = new List<double>();
            var aboveTPercent = new List<double>();
            var cda = new List<double>();


            double infinity = 1.0 / 0.0;
            if (Max == 0) Max = infinity;

            var illResults = illFiles.AsParallel().AsOrdered().Select(file => ReadIllFile(file));
            foreach (var illResult in illResults)
            {
                underTPercent.AddRange(illResult[0]);
                withinTPercent.AddRange(illResult[1]);
                aboveTPercent.AddRange(illResult[2]);
                cda.AddRange(illResult[3]);
            }

            DA.SetDataList(0, underTPercent);
            DA.SetDataList(1, withinTPercent);
            DA.SetDataList(2, aboveTPercent);
            DA.SetDataList(3, cda);
            
        }

        protected override System.Drawing.Bitmap Icon => Properties.Resources.ReadAnnualResultsIII;
        public override Guid ComponentGuid => new Guid("a5df3302-a8b7-468b-8ff8-9d5ceaa9bc1b");

        static List<List<double>> ReadIllFile(string file)
        {
            var underTPercent = new List<double>() { };
            var withinTPercent = new List<double>() { };
            var aboveTPercent = new List<double>() { };
            var cda = new List<double> { };
            var lines = File.ReadAllLines(file, System.Text.Encoding.GetEncoding(1252)).ToList();

            int ptsCount = lines[0].Split(' ').Length - 4;

            for (int i = 0; i < ptsCount; i++)
            {
                underTPercent.Add(0);
                withinTPercent.Add(0);
                aboveTPercent.Add(0);
                cda.Add(0);
            }

            for (int i = 0; i < 8760; i++)
            {
                string[] items = lines[i].Split(' ');
                //A = items;
                var hr = (int)Convert.ToDouble(items[2]);

                //var hrs = new List<int>(){8,9,10};
                int pos = Hours.IndexOf(hr);

                if (pos >= 0)
                {

                    for (int l = 0; l < ptsCount; l++)
                    {
                        int item = Convert.ToInt32(items[l + 4]);
                        int ptsIndex = l;

                        //underTPercent
                        if (item < Min)
                        {
                            underTPercent[ptsIndex] += OneHrPercent;
                            cda[ptsIndex] += OneHrPercent * item / Min;
                        }
                        //aboveTPercent
                        else if (item > Max)
                        {
                            aboveTPercent[ptsIndex] += OneHrPercent;
                        }
                        //withinTPercent
                        else
                        {
                            withinTPercent[ptsIndex] += OneHrPercent;
                            cda[ptsIndex] += OneHrPercent;
                        }
                    }

                }
                else
                {
                    //underTPercent[hr] = pos;
                }
            }

            //processedData for one ill file
            List<List<double>> processedData = new List<List<double>>() { };

            processedData.Add(underTPercent);
            processedData.Add(withinTPercent);
            processedData.Add(aboveTPercent);
            processedData.Add(cda);

            return processedData;


        }
    }
}